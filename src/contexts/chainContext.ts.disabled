// import React, { createContext, useContext } from 'react';
// import { mnemonicToSeedSync as bip39MnemonicToSeed, validateMnemonic, generateMnemonic } from 'bip39';
// import { fromSeed as bip32FromSeed, BIP32Interface } from 'bip32';
// import { toWords as bech32ToWords, encode as bech32Encode } from 'bech32';
// import {
//   publicKeyCreate as secp256k1PublicKeyCreate,
//   ecdsaSign as secp256k1EcdsaSign,
//   ecdsaVerify as secp256k1EcdsaVerify,
// } from 'secp256k1';
// import AES from 'crypto-js/aes';
// import Utf8 from 'crypto-js/enc-utf8';
// import { createHash } from 'crypto';
// import { base64ToBytes, bufferToBytes, bytesToBase64 } from '@tendermint/belt';

// import type { Wallet, KeyPair } from '@tendermint/sig';
// import type { Bech32String, Bytes } from '@tendermint/types';
// import { WindowMessage, WINDOW_MESSAGES, LEVELS, log, MessageParams } from '@provenanceio/wallet-lib';
// import { queryParams } from 'utils';

// const WALLET_TYPE = 'PROVENANCE';

// const { origin } = queryParams as MessageParams;

// class ChainService {
//   private hdPath: string;
//   private _mnemonic = ''; // only stored between import/generation and encryption
//   private _privateKey = ''; // only stored between import and encryption
//   private _publicKeyB64 = '';
//   private _chainId = process.env.REACT_APP_PROVENANCE_CHAIN_ID as string;
//   private _signVerification: { randomB64?: string; signedB64?: string } = {};
//   encryptedKeychainValue = '';
//   keychainAccountName = '';
//   address = '';

//   constructor(
//     private bech32MainPrefix = process.env.REACT_APP_PROVENANCE_WALLET_PREFIX as string,
//     coinType = Number(process.env.REACT_APP_PROVENANCE_WALLET_COIN_TYPE as string),
//     private mnemonicWordCount = 24
//   ) {
//     this.hdPath = `m/44'/${coinType}'/0'/0/0${process.env.REACT_APP_HD_PATH_LAST_HARDENED === 'true' ? `'` : ''}`;
//   }

//   postMessage(message: WINDOW_MESSAGES, messageData?: any) {
//     let returnMessage: WindowMessage | undefined;
//     try {
//       switch (message) {
//         case WINDOW_MESSAGES.CONNECTED:
//           returnMessage = {
//             ...this._signVerification,
//             publicKeyB64: this._publicKeyB64,
//             keychainAccountName: this.keychainAccountName,
//             address: this.address,
//             walletType: WALLET_TYPE,
//             txCallbackUrl: `${process.env.REACT_APP_PROVENANCE_WALLET_URL}/transaction`,
//             message,
//           };
//           break;
//         case WINDOW_MESSAGES.SIGNATURE_COMPLETE:
//         case WINDOW_MESSAGES.TRANSACTION_COMPLETE:
//           returnMessage = {
//             publicKeyB64: this._publicKeyB64,
//             keychainAccountName: this.keychainAccountName,
//             address: this.address,
//             walletType: WALLET_TYPE,
//             txCallbackUrl: `${process.env.REACT_APP_PROVENANCE_WALLET_URL}/transaction`,
//             message,
//             ...messageData,
//           };
//           break;
//         case WINDOW_MESSAGES.CLOSE:
//         case WINDOW_MESSAGES.TRANSACTION_FAILED:
//           returnMessage = { message };
//           break;
//         default:
//           log(`Unsupported message `, LEVELS.ERROR);
//       }
//       if (returnMessage && window?.opener) window.opener.postMessage(returnMessage, origin || '*');
//     } catch (e) {
//       window.close();
//     }
//   }

//   validateMnemonic(mnemonic: string): boolean {
//     return validateMnemonic(mnemonic);
//   }

//   createWallet(privateKeyString?: string): Wallet {
//     try {
//       const privateKey = base64ToBytes(privateKeyString || this._privateKey);
//       const publicKey = secp256k1PublicKeyCreate(privateKey);
//       const address = this.createAddress(publicKey);
//       this.address = address;
//       this._publicKeyB64 = bytesToBase64(publicKey);
//       return {
//         privateKey,
//         publicKey,
//         address,
//       };
//     } catch (e) {
//       throw new Error('Failed to create wallet from private key');
//     }
//   }

//   createSignVerification(wallet: Wallet) {
//     const { privateKey } = wallet;
//     const random = new Uint8Array(50);
//     const randomBytes = crypto.getRandomValues(random);
//     this._signVerification = {
//       randomB64: bytesToBase64(randomBytes),
//       signedB64: bytesToBase64(this.signBytes(randomBytes, privateKey)),
//     };
//   }

//   createMasterKeyFromMnemonic(mnemonic: string): BIP32Interface {
//     const seed = bip39MnemonicToSeed(mnemonic);
//     return bip32FromSeed(seed);
//   }

//   createKeyPairFromMasterKey(masterKey: BIP32Interface, path: string): KeyPair {
//     const buffer = masterKey.derivePath(path).privateKey;
//     if (!buffer) {
//       throw new Error('could not derive private key');
//     }

//     const privateKey = bufferToBytes(buffer);
//     const publicKey = secp256k1PublicKeyCreate(privateKey, true);

//     return {
//       privateKey,
//       publicKey,
//     };
//   }

//   sha256(bytes: Bytes): Bytes {
//     const buffer1 = bytes instanceof Buffer ? bytes : Buffer.from(bytes);
//     const buffer2 = createHash('sha256').update(buffer1).digest();

//     return bufferToBytes(buffer2);
//   }

//   ripemd160(bytes: Bytes): Bytes {
//     const buffer1 = bytes instanceof Buffer ? bytes : Buffer.from(bytes);
//     const buffer2 = createHash('ripemd160').update(buffer1).digest();

//     return bufferToBytes(buffer2);
//   }

//   createAddress(publicKey: Bytes, prefix: string = this.bech32MainPrefix): Bech32String {
//     const hash1 = this.sha256(publicKey);
//     const hash2 = this.ripemd160(hash1);
//     const words = bech32ToWords(hash2);

//     return bech32Encode(prefix, words);
//   }

//   createWalletFromMasterKey(masterKey: BIP32Interface, prefix: string, path: string): Wallet {
//     const { privateKey, publicKey } = this.createKeyPairFromMasterKey(masterKey, path);

//     const address = this.createAddress(publicKey, prefix);

//     return {
//       privateKey,
//       publicKey,
//       address,
//     };
//   }

//   signBytes(bytes: Uint8Array, privateKey: Bytes): Uint8Array {
//     const hash = this.sha256(bytes);
//     const { signature } = secp256k1EcdsaSign(hash, privateKey);

//     return signature;
//   }

//   verifyTx(signedBytes: Uint8Array, pubKey: string, signature: Uint8Array): boolean {
//     const publicKey = base64ToBytes(pubKey);
//     const hash = this.sha256(signedBytes);

//     return secp256k1EcdsaVerify(signature, hash, publicKey);
//   }

//   get privateKey() {
//     return this._privateKey;
//   }

//   setPrivateKey(key: string) {
//     this._privateKey = key;
//   }

//   get PrivateKey() {
//     return this._privateKey;
//   }

//   get chainId() {
//     return this._chainId;
//   }

//   setMnemonic(mnemonic: string) {
//     this._mnemonic = mnemonic;
//     const masterKey = this.createMasterKeyFromMnemonic(mnemonic);
//     const { privateKey } = this.createWalletFromMasterKey(masterKey, this.bech32MainPrefix, this.hdPath);
//     this._privateKey = bytesToBase64(privateKey);
//   }

//   get mnemonic() {
//     return this._mnemonic;
//   }

//   getMnemonicNthWord(n: number) {
//     return this._mnemonic.split(' ')[n - 1];
//   }

//   encryptForKeychain(password: string): void {
//     this.encryptedKeychainValue = AES.encrypt(this._privateKey, password).toString();
//     this._mnemonic = '';
//     this._privateKey = '';
//   }

//   decryptFromKeychain(password: string): string {
//     try {
//       return AES.decrypt(this.encryptedKeychainValue, password).toString(Utf8);
//     } catch (e) {
//       throw new Error('Failed to decrypt private key');
//     }
//   }

//   generateMnemonic(): string {
//     const strength = (this.mnemonicWordCount / 3) * 32;
//     return generateMnemonic(strength);
//   }
// }

// type State = {
//   chainService: ChainService;
// };

// const chainService = new ChainService();

// const StateContext = createContext<State | undefined>(undefined);

// const ChainContextProvider = ({ children }: { children: React.ReactElement }) => {
//   return <StateContext.Provider value={{ chainService }}>{children}</StateContext.Provider>;
// };

// const useChain = () => {
//   const context = useContext(StateContext);
//   if (context === undefined) {
//     throw new Error('useChain must be used within a ChainContextProvider');
//   }
//   return context;
// };

// export { ChainContextProvider, useChain };